---
title: "1099 - 알 수 없는 문장"
date: 2024-03-03 00:00:01
categories:
- BOJ
tags:
- dp
---

**알 수 없는 문장**

길이 $N(1\leq N\leq50)$의 문자열 $S$이 주어지고, 주어진 부분 문자열 $M(1\leq M\leq 50)$개를 적절히 이어붙여 $S$를 만들어야 합니다. 한 부분 문자열 $T$에서는 문자의 순서를 임의로 바꿀 수 있으며, 그 비용은 원래 $T$와 일치하지 않는 문자의 갯수만큼 듭니다. 이 비용을 최소화 하는 것이 문제입니다.

$dp[i]$를 $i$번째 문자부터 끝까지 완성시키는데 최소 비용이라고 정의한 뒤 모든 부분문자열 $T$를 시도해보면 됩니다. 

```cpp 
string s;
int n, dp[51];
vector<string> a;

int dfs(int id) {
    int& ret = dp[id];
    if(ret != -1) return ret;
    if(id == sz(s)) return ret = 0;
    ret = INF;
    for(int i=0; i<n; i++) if(id + sz(a[i]) <= sz(s)) {
        vector<int> cnt(26);
        for(int j=id,k=0; j<id + sz(a[i]); j++,k++) {
            cnt[s[j]-'a']++;
            cnt[a[i][k]-'a']--;
        } 
        int suc = 1;
        for(int j=0; j<26; j++) if(cnt[j]) suc = 0;
        if(!suc) continue;
        int score = 0;
        for(int j=id,k=0; j<id + sz(a[i]); j++,k++) {
            if(s[j] != a[i][k]) {
                score++;
            }
        } 
        ret = min(ret, score + dfs(id + sz(a[i])));
    }
    return ret;
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    memset(dp, -1, sizeof dp);
    cin >> s >> n;
    a = vector<string>(n);
    for(int i=0; i<n; i++) cin >> a[i];
    cout << (dfs(0)==INF?-1:dfs(0)) << '\n';
}
```

